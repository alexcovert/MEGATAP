
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

public class MeshCollisionBaker
{

    private const string kBakedMeshName = "Autogenerated Mesh Collider";


    [MenuItem("Collisions/Bake Collision Mesh")]
    public static void BakeCollisionMeshes()
    {
        for (int i = 0; i < SceneManager.sceneCount; ++i)
        {
            Scene s = SceneManager.GetSceneAt(i);
            BakeCollisionMeshesFromScene(s);
        }
    }

    private static void BakeCollisionMeshesFromScene(Scene s)
    {
        var colliders = CollectCollidersFromScene(s);
        GameObject combinedCollider = BakeCombinedCollider(colliders);


        SceneManager.MoveGameObjectToScene(combinedCollider, s);
        combinedCollider.gameObject.isStatic = true;

    }

    private static GameObject BakeCombinedCollider(List<Collider> colliders)
    {
        GameObject combinedCollider = null;
        MeshCollider meshCollider = null;
        List<int> tris = new List<int>();
        List<Vector3> verts = new List<Vector3>();
        for (int i = 0; i < colliders.Count; ++i)
        {
            if (colliders[i].name == kBakedMeshName)
            {
                combinedCollider = colliders[i].gameObject;
                meshCollider = combinedCollider.GetComponent<MeshCollider>();
            }
            else if(colliders[i].GetComponent<MonoBehaviour>() != null)
            {
                //skip anything with a component - assume it's moving or the like
            }
            else if(!colliders[i].isTrigger) //TODO: better filtering
            {
                BakeCollider(tris, verts, colliders[i]);
            }
        }

        Mesh generatedMesh = new Mesh();
        generatedMesh.vertices = verts.ToArray();
        generatedMesh.triangles = tris.ToArray();
        if (combinedCollider == null)
        {
            combinedCollider = new GameObject();
            combinedCollider.name = kBakedMeshName;
        }
        if (meshCollider == null)
        {
            meshCollider = combinedCollider.AddComponent<MeshCollider>();
        }
        //MeshFilter filter = combinedCollider.GetComponent<MeshFilter>();
        //if(filter == null)
        //{
        //    filter = combinedCollider.AddComponent<MeshFilter>();
        //    combinedCollider.AddComponent<MeshRenderer>();
        //}
        //filter.mesh = generatedMesh;

        meshCollider.sharedMesh = generatedMesh;
        combinedCollider.tag = "Platform";
        return combinedCollider;
    }

    //private static void BakeCollider(List<int> tris, List<Vector3> verts, Collider collider)
    //{
    //    if (collider is BoxCollider)
    //    {
    //        BakeSpecificCollider(tris, verts, collider as BoxCollider);
    //    }
    //    else if (collider is MeshCollider)
    //    {
    //        BakeSpecificCollider(tris, verts, collider as MeshCollider);
    //    }
    //    else
    //    {
    //        Debug.LogError("Unhandled collider type - " + collider, collider);
    //    }
    //}


    private static void BakeCollider(List<int> tris, List<Vector3> verts, Collider collider) 
    {
        if (collider is BoxCollider)
        {
            BakeSpecificCollider(tris, verts, collider as BoxCollider);
        }
        else if (collider is MeshCollider)
        {
            BakeSpecificCollider(tris, verts, collider as MeshCollider);
        }
        else
        {
            Debug.LogError("Unhandled collider type - " + collider, collider);
        }
    }

    private static void BakeSpecificCollider(List<int> tris, List<Vector3> verts, BoxCollider collider)
    {
        Vector3 maxes = collider.center + (collider.size * .5f);
        Vector3 mins = collider.center - (collider.size * .5f);

        int vert0 = verts.Count;
        verts.Add(new Vector3(mins.x, mins.y, mins.z));
        verts.Add(new Vector3(mins.x, mins.y, maxes.z));
        verts.Add(new Vector3(mins.x, maxes.y, mins.z));
        verts.Add(new Vector3(mins.x, maxes.y, maxes.z));
        verts.Add(new Vector3(maxes.x, mins.y, mins.z));
        verts.Add(new Vector3(maxes.x, mins.y, maxes.z));
        verts.Add(new Vector3(maxes.x, maxes.y, mins.z));
        verts.Add(new Vector3(maxes.x, maxes.y, maxes.z));

        for(int i = vert0; i < verts.Count; ++i)
        {
            verts[i] = collider.transform.TransformPoint(verts[i]);
        }
            
        //left
        tris.Add(vert0 + 1);
        tris.Add(vert0 + 2);
        tris.Add(vert0 + 0);

        tris.Add(vert0 + 3);
        tris.Add(vert0 + 2);
        tris.Add(vert0 + 1);

        //front
        tris.Add(vert0 + 4);
        tris.Add(vert0 + 0);
        tris.Add(vert0 + 2);

        tris.Add(vert0 + 4);
        tris.Add(vert0 + 2);
        tris.Add(vert0 + 6);

        //right
        tris.Add(vert0 + 4);
        tris.Add(vert0 + 6);
        tris.Add(vert0 + 5);

        tris.Add(vert0 + 5);
        tris.Add(vert0 + 6);
        tris.Add(vert0 + 7);

        //back
        tris.Add(vert0 + 1);
        tris.Add(vert0 + 5);
        tris.Add(vert0 + 3);

        tris.Add(vert0 + 5);
        tris.Add(vert0 + 7);
        tris.Add(vert0 + 3);

        //top
        tris.Add(vert0 + 2);
        tris.Add(vert0 + 3);
        tris.Add(vert0 + 6);

        tris.Add(vert0 + 6);
        tris.Add(vert0 + 3);
        tris.Add(vert0 + 7);

        //bottom
        tris.Add(vert0 + 5);
        tris.Add(vert0 + 0);
        tris.Add(vert0 + 4);

        tris.Add(vert0 + 5);
        tris.Add(vert0 + 1);
        tris.Add(vert0 + 0);

        collider.enabled = true;
    }
        
    private static void BakeSpecificCollider(List<int> tris, List<Vector3> verts, MeshCollider collider)
    {
        Transform transform = collider.transform;
        Vector3[] tempVerts = collider.sharedMesh.vertices;
        int[] tempTris = collider.sharedMesh.triangles;
            
        //transform vertexes
        for (int i = 0; i < tempVerts.Length; ++i)
        {
            tempVerts[i] = transform.TransformPoint(tempVerts[i]);
        }

        //transform triangle indicies
        int vert0Index = verts.Count;
        for (int i = 0; i < tempTris.Length; ++i)
        {
            tempTris[i] += vert0Index;
        }

        verts.AddRange(tempVerts);
        tris.AddRange(tempTris);
    }

    private static List<Collider> CollectCollidersFromScene(Scene s)
    {
        GameObject[] allObjects = s.GetRootGameObjects();
        List<Collider> allColliders = new List<Collider>();
        for (int i = 0; i < allObjects.Length; ++i)
        {
            allColliders.AddRange(allObjects[i].GetComponentsInChildren<Collider>());
        }
        return allColliders;
    }
}
